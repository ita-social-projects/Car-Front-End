"use strict";
/**
 * TypeScript version of Axios mock for unit testing with [Jest](https://facebook.github.io/jest/).
 * This file is based on https://gist.github.com/tux4/36006a1859323f779ab0
 *
 * @author   knee-cola <nikola.derezic@gmail.com>
 * @license  @license MIT License, http://www.opensource.org/licenses/MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
const jest_mock_promise_1 = require("jest-mock-promise");
/** a FIFO queue of pending request */
const _pending_requests = [];
const _newReq = (url, data, config) => {
    const promise = new jest_mock_promise_1.default();
    _pending_requests.push({
        config,
        data,
        promise,
        url,
    });
    return (promise);
};
const MockAxios = jest.fn(_newReq);
// mocking Axios methods
MockAxios.get = jest.fn(_newReq);
MockAxios.post = jest.fn(_newReq);
MockAxios.put = jest.fn(_newReq);
MockAxios.patch = jest.fn(_newReq);
MockAxios.delete = jest.fn(_newReq);
MockAxios.all = jest.fn((values) => Promise.all(values));
MockAxios.head = jest.fn(_newReq);
MockAxios.options = jest.fn(_newReq);
MockAxios.create = jest.fn(() => MockAxios);
MockAxios.popPromise = (promise) => {
    if (promise) {
        // remove the promise from pending queue
        for (let ix = 0; ix < _pending_requests.length; ix++) {
            const req = _pending_requests[ix];
            if (req.promise === promise) {
                _pending_requests.splice(ix, 1);
                return (req.promise);
            }
        }
    }
    else {
        // take the oldest promise
        const req = _pending_requests.shift();
        return (req ? req.promise : void 0);
    }
};
MockAxios.popRequest = (request) => {
    if (request) {
        const ix = _pending_requests.indexOf(request);
        if (ix === -1) {
            return (void 0);
        }
        _pending_requests.splice(ix, 1);
        return (request);
    }
    else {
        return (_pending_requests.shift());
    }
};
/**
 * Removes an item form the queue, based on it's type
 * @param queueItem
 */
const popQueueItem = (queueItem = null) => {
    // first le't pretend the param is a queue item
    const request = MockAxios.popRequest(queueItem);
    if (request) {
        // IF the request was found
        // > set the promise
        return (request.promise);
    }
    else {
        // ELSE maybe the `queueItem` is a promise (legacy mode)
        return (MockAxios.popPromise(queueItem));
    }
};
MockAxios.mockResponse = (response, queueItem = null) => {
    // replacing missing data with default values
    response = Object.assign({
        config: {},
        data: {},
        headers: {},
        status: 200,
        statusText: "OK",
    }, response);
    // resolving the Promise with the given response data
    popQueueItem(queueItem).resolve(response);
};
MockAxios.mockError = (error = {}, queueItem = null) => {
    // resolving the Promise with the given response data
    popQueueItem(queueItem).reject(Object.assign({}, error));
};
MockAxios.lastReqGet = () => {
    return (_pending_requests[_pending_requests.length - 1]);
};
MockAxios.lastPromiseGet = () => {
    const req = MockAxios.lastReqGet();
    return (req ? req.promise : void 0);
};
MockAxios.reset = () => {
    // remove all the requests
    _pending_requests.splice(0, _pending_requests.length);
    // resets all information stored in the mockFn.mock.calls and mockFn.mock.instances arrays
    MockAxios.get.mockClear();
    MockAxios.post.mockClear();
    MockAxios.put.mockClear();
    MockAxios.patch.mockClear();
    MockAxios.delete.mockClear();
    MockAxios.head.mockClear();
    MockAxios.options.mockClear();
    MockAxios.all.mockClear();
};
// this is a singleton object
exports.default = MockAxios;
//# sourceMappingURL=mock-axios.js.map